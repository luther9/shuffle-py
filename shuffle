#!/usr/bin/env python3

# Copyright 2018 Luther Thompson
# This program is licensed under CC-0.

# TODO:
# Detect streaks and always keep them together when splitting.

import argparse
import collections
import functools
import itertools
import random
import sys

import ilinkedlist

parser = argparse.ArgumentParser(add_help=False)
parser.add_argument('-help', action='help')
parser.add_argument('-seed', type=int, help='Random number seed')
parser.add_argument(
  'uniques', type=int, help='Number of unique, unshuffled cards',
)
parser.add_argument(
  'identicals', nargs='*', type=int,
  help='Numbers of identical or pre-shuffled cards',
)


# id is used to see if this card is identical to other cards.
# position is the card's final position in the shuffled deck.
Card = collections.namedtuple('Card', 'id position')


def getTarget(card, cutoff):
  """True if the card belongs in pile B."""
  return card.position < cutoff


def getTransfer(hand, cutoff):
  target = getTarget(hand.car, cutoff)
  transfer = ilinkedlist.nil
  while hand and getTarget(hand.car, cutoff) == target:
    transfer = ilinkedlist.Pair(hand.car, transfer)
    hand = hand.cdr
  return target, reversed(transfer), hand


def bottomIdGroup(pile):
  """Return pile split into two lists with the second one being all cards at
  the end with the same id.
  """
  head = currentHead = ilinkedlist.nil
  for current in pile.nodes():
    if pile.car.id != current.car.id:
      head = currentHead
      pile = current
    currentHead = ilinkedlist.Pair(current.car, currentHead)
  return reversed(head), pile


def topIdGroup(pile):
  """Return pile split into two lists with the first one being all cards at the
  top with the same id.

  pile must not be nil.
  """
  id = pile.car.id
  head = ilinkedlist.nil
  while pile and pile.car.id == id:
    head = ilinkedlist.Pair(pile.car, head)
    pile = pile.cdr
  return reversed(head), pile


def findMatchingStreak(pile, target):
  """If pile contains a streak that would be continued by target, return pile
  with that streak moved to the bottom. Otherwise, return None.
  """
  # head: Not in the streak we want.
  # currentHead: Everything before current. Assigned to head when we change
  # streaks.
  # streak: The current streak.
  head = currentHead = streak = ilinkedlist.nil
  for current in pile.nodes():
    currentHead = ilinkedlist.Pair(current.car, currentHead)
    streak = ilinkedlist.Pair(current.car, streak)
    if streak.car.position + 1 == target:
      return (current.cdr + reversed(streak)).appendReverse(head)
    if current.cdr and streak.car.position + 1 != current.cdr.car.position:
      head = currentHead
      streak = ilinkedlist.nil


def topStreak(pile):
  """Return a tuple with the top streak of pile separated from the rest."""
  head = ilinkedlist.nil
  for pair in pile.nodes():
    head = ilinkedlist.Pair(pair.car, head)
    if not pair.cdr or pair.car.position + 1 != pair.cdr.car.position:
      return reversed(head), pair.cdr


def combineIdenticals(upper, lower):
  """Combine two homogeneous piles into one list.

  If possible, rearrange the cards to create a new streak between them.
  """
  # We search lower first so that if the bottom of upper and the top of lower
  # already match, we can keep them sorted rather than try some other
  # rearrangement.
  lowerHead = ilinkedlist.nil
  for lowerTail in lower.nodes():
    fixedUpper = findMatchingStreak(upper, lowerTail.car.position)
    if fixedUpper is not None:
      streak, tail = topStreak(lowerTail)
      return fixedUpper + (streak + tail.appendReverse(lowerHead))
    lowerHead = ilinkedlist.Pair(lowerTail.car, lowerHead)
  return upper + lower


def combine(a, b):
  """Combine two card piles into a single linked list."""
  if not b:
    return a
  aMain, aGroup = bottomIdGroup(a)
  bGroup, bMain = topIdGroup(b)
  return aMain + (combineIdenticals(aGroup, bGroup) + bMain)


def split(hand):
  """Guide the user to split the hand pile into two piles."""
  median = min(c.position for c in hand) + len(hand) / 2
  # Round off the cutoff in favor of a larger B pile.
  cutoff = int(median) + bool(median % 1)
  piles = ilinkedlist.nil, ilinkedlist.nil
  while hand:
    target, transfer, hand = getTransfer(hand, cutoff)
    letter = 'B' if target else 'A'
    input(f'{len(transfer)} to {letter}')
    piles = tuple(
      pile if i != target else combine(transfer, pile)
      for i, pile in enumerate(piles)
    )
  return piles


def main(argv):
  args = parser.parse_args(argv)
  uniques = args.uniques
  identicals = args.identicals
  nCards = uniques + sum(identicals)
  # This gives us the position for each card.
  pool = iter(random.Random(args.seed).sample(range(nCards), nCards))
  # This gives us the id for each group of identical cards.
  idPool = itertools.count()

  def addGroup(deck, n):
    """deck is the deck we've built so far. n is the number of cards to add."""
    id = next(idPool)
    return combine(
      ilinkedlist.new(
        Card(id, position) for position in sorted(itertools.islice(pool, n))
      ),
      deck,
    )

  piles = ilinkedlist.new((
    functools.reduce(
      addGroup, itertools.chain(itertools.repeat(1, uniques), identicals),
      ilinkedlist.nil,
    ),
  ))
  while piles:
    hand = piles.car
    rest = piles.cdr
    if all(
        len(node) == 1 or node.car.position + 1 == node.cdr.car.position
        for node in hand.nodes()
    ):
      print(f'Pile of {len(hand)} cards is shuffled.')
      piles = rest
    else:
      print(*(len(pile) for pile in piles))
      try:
        newPiles = split(hand)
      except EOFError:
        print()
        break
      piles = newPiles + rest


if __name__ == '__main__':
  main(sys.argv[1:])
