#!/usr/bin/env python3

# Copyright 2018-2019 Luther Thompson
# This program is licensed under CC-0.

import argparse
from dataclasses import dataclass
import functools
import itertools
from random import Random
import sys
from typing import Optional

parser = argparse.ArgumentParser(add_help=False)
parser.add_argument('-help', action='help')
parser.add_argument('-seed', type=int, help='Random number seed')
parser.add_argument(
    'uniques', type=int, help='Number of unique, unshuffled cards',
)
parser.add_argument(
    'identicals', nargs='*', type=int,
    help='Numbers of identical or pre-shuffled cards',
)


@dataclass(frozen=True)
class Streak:
    """Represents a set of cards with consecutive positions.

    position: The Streak's final position in the shuffled deck.
    len: The length of the Streak.
    id: Identical cards have the same id. id is None if the Streak would
    otherwise have multiple ids or if the Streak has a unique card.
    """
    position: int
    len: int
    id: Optional[int] = None


def getTarget(card, median):
    """True if the card belongs in pile B."""
    return card.position + card.len / 2 <= median


def getTransfer(hand, median):
    """Return a 3-tuple describing a transfer from the hand to a new pile.

    0: The target pile. False for A, True for B.
    1: The list of streaks that go to the target pile.
    2: The remaining hand.
    """
    target = getTarget(hand[0], median)
    for i, _ in filter(
        lambda e: getTarget(e[1], median) != target,
        enumerate(hand),
    ):
        return target, hand[:i], hand[i:]
    return target, hand, ()


def unequalId(id):
    """Return a function that checks if its argument[1].id is unequal to id."""
    return lambda e: e[1].id != id


def bottomIdGroup(pile):
    """Return pile split into two lists with the second one being all cards at
    the end with the same id.

    pile must not be empty. If the last id is None, split off only one streak.
    """
    id = pile[-1].id
    if id is None:
        return pile[:-1], pile[-1:]
    for i, _ in filter(unequalId(id), enumerate(reversed(pile))):
        return pile[:-i], pile[-i:]
    return (), pile


def topIdGroup(pile):
    """Return pile split into two lists with the first one being all cards at the
    top with the same id.

    pile must not be nil. If the first id is None, split off only one streak.
    """
    id = pile[0].id
    if id is None:
        return pile[:1], pile[1:]
    for i, _ in filter(unequalId(id), enumerate(pile)):
        return pile[:i], pile[i:]
    return pile, ()


def findMatchingStreak(pile, target):
    """If pile contains a streak that would be continued by target, return pile
    with that streak moved out to a second value. Otherwise, return None. pile
    must be homogeneous.
    """
    for i, streak in enumerate(pile):
        if streak.position + streak.len == target:
            return pile[:i] + pile[i+1:], streak


def combineIdenticals(upper, lower):
    """Combine two homogeneous piles into one list.

    If possible, rearrange the cards to create a new streak between them.
    """
    # We search lower first so that if the bottom of upper and the top of lower
    # already match, we can keep them sorted rather than try some other
    # rearrangement.
    for i, lowerStreak in enumerate(lower):
        rearrangement = findMatchingStreak(upper, lowerStreak.position)
        if rearrangement:
            fixedUpper, last = rearrangement
            return (
                fixedUpper
                + (Streak(last.position, last.len + lowerStreak.len),)
                + lower[:i]
                + lower[i+1:]
            )
    return upper + lower


def combine(a, b):
    """Combine two card piles into a single linked list."""
    if not b:
        return a
    aMain, aGroup = bottomIdGroup(a)
    bGroup, bMain = topIdGroup(b)
    return aMain + combineIdenticals(aGroup, bGroup) + bMain


def split(hand):
    """Guide the user to split the hand pile into two piles."""
    median = min(c.position for c in hand) + pileSize(hand) / 2
    piles = (), ()
    while hand:
        target, transfer, hand = getTransfer(hand, median)
        letter = 'B' if target else 'A'
        input(f'{pileSize(transfer)} to {letter}')
        piles = tuple(
            pile if i != target else combine(transfer, pile)
            for i, pile in enumerate(piles)
        )
    return piles


def idGroup(n, id, pool):
    """Make a tuple of streaks of n cards with the same id.

    Positions are taken from the iterator pool.
    """

    def f(lst, position):
        tackedOn = lst + (Streak(position, 1, id),)
        if not lst:
            return tackedOn
        last = lst[-1]
        return (
            tackedOn
            if position != last.position + 1
            else lst[:-1] + (Streak(last.position, last.len + 1, id),)
        )

    return functools.reduce(f, sorted(itertools.islice(pool, n)), ())


def pileSize(pile):
    """Return the sum of the lengths of all streaks in pile."""
    return sum(x.len for x in pile)


def main(argv):
    args = parser.parse_args(argv)
    uniques = args.uniques
    identicals = args.identicals
    nCards = uniques + sum(identicals)
    # This gives us the position for each card.
    pool = iter(Random(args.seed).sample(range(nCards), nCards))
    # This gives us the id for each group of identical cards.
    idPool = itertools.count()
    piles = (
        functools.reduce(
            lambda deck, n: combine(idGroup(n, next(idPool), pool), deck),
            itertools.chain(itertools.repeat(1, uniques), identicals),
            (),
        ),
    )
    while piles:
        hand = piles[0]
        size = pileSize(hand)
        rest = piles[1:]
        if len(hand) < 2:
            print(f'Pile of {size} cards is shuffled.')
            piles = rest
        else:
            print(*(pileSize(pile) for pile in piles))
            try:
                newPiles = split(hand)
            except EOFError:
                print()
                break
            piles = newPiles + rest


if __name__ == '__main__':
    main(sys.argv[1:])
