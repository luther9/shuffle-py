#!/usr/bin/env python3

# Copyright 2018 Luther Thompson
# This program is licensed under CC-0.

import argparse
import collections
import functools
import itertools
import random
import sys

import ilinkedlist

parser = argparse.ArgumentParser(add_help=False)
parser.add_argument('-help', action='help')
parser.add_argument('-seed', type=int, help='Random number seed')
parser.add_argument(
  'uniques', type=int, help='Number of unique, unshuffled cards',
)
parser.add_argument(
  'identicals', nargs='*', type=int,
  help='Numbers of identical or pre-shuffled cards',
)


# position is the streak's final position in the shuffled deck.
# len is the length of the streak.
# id is used to see if this streak's cards are identical to other cards. An id
# of None indicates that this streak mixes different ids, and therefore can't be
# rearranged.
Streak = collections.namedtuple('Streak', 'position len id')


def getTarget(card, median):
  """True if the card belongs in pile B."""
  return card.position + card.len / 2 <= median


def getTransfer(hand, median):
  """Return a 3-tuple describing a transfer from the hand to a new pile.

  0: The target pile. False for A, True for B.
  1: The list of streaks that go to the target pile.
  2: The remaining hand.
  """
  target = getTarget(hand.car, median)
  transfer = ilinkedlist.nil
  while hand and getTarget(hand.car, median) == target:
    transfer = ilinkedlist.Pair(hand.car, transfer)
    hand = hand.cdr
  return target, reversed(transfer), hand


def bottomIdGroup(pile):
  """Return pile split into two lists with the second one being all cards at
  the end with the same id.
  """
  head = currentHead = ilinkedlist.nil
  for current in pile.pairs():
    if current.car.id is None or pile.car.id != current.car.id:
      head = currentHead
      pile = current
    currentHead = ilinkedlist.Pair(current.car, currentHead)
  return reversed(head), pile


def topIdGroup(pile):
  """Return pile split into two lists with the first one being all cards at the
  top with the same id.

  pile must not be nil.
  """
  id = pile.car.id
  if id is None:
    return ilinkedlist.new((pile.car,)), pile.cdr
  head = ilinkedlist.nil
  while pile and pile.car.id == id:
    head = ilinkedlist.Pair(pile.car, head)
    pile = pile.cdr
  return reversed(head), pile


def findMatchingStreak(pile, target):
  """If pile contains a streak that would be continued by target, return pile
  with that streak moved out to a second value. Otherwise, return None. pile
  must be homogeneous.
  """
  head = ilinkedlist.nil
  for current in pile.pairs():
    streak = current.car
    if streak.position + streak.len == target:
      return current.cdr.appendReverse(head), streak
    head = ilinkedlist.Pair(streak, head)


def combineIdenticals(upper, lower):
  """Combine two homogeneous piles into one list.

  If possible, rearrange the cards to create a new streak between them.
  """
  # We search lower first so that if the bottom of upper and the top of lower
  # already match, we can keep them sorted rather than try some other
  # rearrangement.
  lowerHead = ilinkedlist.nil
  for lowerTail in lower.pairs():
    rearrangement = findMatchingStreak(upper, lowerTail.car.position)
    if rearrangement is not None:
      fixedUpper, last = rearrangement
      return fixedUpper + ilinkedlist.Pair(
        Streak(last.position, last.len + lowerTail.car.len, None),
        lowerTail.cdr.appendReverse(lowerHead),
      )
    lowerHead = ilinkedlist.Pair(lowerTail.car, lowerHead)
  return upper + lower


def combine(a, b):
  """Combine two card piles into a single linked list."""
  if not b:
    return a
  aMain, aGroup = bottomIdGroup(a)
  bGroup, bMain = topIdGroup(b)
  return aMain + (combineIdenticals(aGroup, bGroup) + bMain)


def split(hand):
  """Guide the user to split the hand pile into two piles."""
  median = min(c.position for c in hand) + pileSize(hand) / 2
  piles = ilinkedlist.nil, ilinkedlist.nil
  while hand:
    target, transfer, hand = getTransfer(hand, median)
    letter = 'B' if target else 'A'
    input(f'{pileSize(transfer)} to {letter}')
    piles = tuple(
      pile if i != target else combine(transfer, pile)
      for i, pile in enumerate(piles)
    )
  return piles


def idGroup(n, id, pool):
  """Make a linked list of streaks of n cards with the same id.

  Positions are taken from the iterator pool.
  """

  def f(lst, position):
    return (
      ilinkedlist.Pair(Streak(position, 1, id), lst)
      if not lst or position + 1 != lst.car.position
      else ilinkedlist.Pair(Streak(position, lst.car.len + 1, id), lst.cdr)
    )

  return functools.reduce(
    f, sorted(itertools.islice(pool, n), reverse=True), ilinkedlist.nil,
  )


def pileSize(pile):
  """Return the sum of the lengths of all streaks in pile."""
  return sum(x.len for x in pile)


def main(argv):
  args = parser.parse_args(argv)
  uniques = args.uniques
  identicals = args.identicals
  nCards = uniques + sum(identicals)
  # This gives us the position for each card.
  pool = iter(random.Random(args.seed).sample(range(nCards), nCards))
  # This gives us the id for each group of identical cards.
  idPool = itertools.count()
  piles = ilinkedlist.new((
    functools.reduce(
      lambda deck, n: combine(idGroup(n, next(idPool), pool), deck),
      itertools.chain(itertools.repeat(1, uniques), identicals),
      ilinkedlist.nil,
    ),
  ))
  while piles:
    hand = piles.car
    size = pileSize(hand)
    rest = piles.cdr
    if len(hand) < 2:
      print(f'Pile of {size} cards is shuffled.')
      piles = rest
    else:
      print(*(pileSize(pile) for pile in piles))
      try:
        newPiles = split(hand)
      except EOFError:
        print()
        break
      piles = newPiles + rest


if __name__ == '__main__':
  main(sys.argv[1:])
